# On-Orbit Software Reconstruction Workflow

This section details the structure of the software packages and the on-orbit installation process.

## Software Package Structure

All software reconstruction packages are uploaded and processed from the ~/packages/tgz directory on the satellite's payload computer.

### Package Naming Convention
The final package name on the satellite must follow the format: <ID>-<MD5>.tgz.
<ID>: The unique Experiment ID.
<MD5>: The MD5 checksum of the entire .tgz compressed file, generated using md5sum.

The ground packaging script produces a <ID>-<MD5>.pkg file. This .pkg is a wrapper around the .tgz file to facilitate interaction with the OBC. The on-orbit services automatically handle the conversion from .pkg to the required .tgz format.

### Package Structure

A reconstruction package, when uncompressed, must have the following structure:

```
.
├── install.sh      (Required)
└── [other_files]   (Optional)
```

The install.sh script is the entry point for the entire installation process.

## The install.sh Script

The install.sh script is responsible for the complete installation of the experimental software:

(1) Targeted Updates: The script should perform either incremental or full updates to the content within the designated experiment directory (~/experiment/). See the "File Path Planning" document for the specified directory structure.

(2) Isolation: The script must not modify or affect the contents of any other directories on the system.

(3) Exit Codes: The script must return an exit code of 0 on successful execution and a non-zero value otherwise. This is critical for automated verification.

(4) Relative Paths: The script can operate on other files within the package using relative paths. The relative positions of install.sh and other files are guaranteed to be preserved during the packaging and decompression processes.


# Pre-Launched Ground Testing Procedures
To prevent on-orbit failures and minimize unnecessary time and resource expenditure, all experimental software must undergo rigorous ground testing before being scheduled for an on-orbit run. Ground testing is divided into two main parts: Runtime Testing and Remote Command Testing.

## Runtime Testing
This phase verifies that the experimental scripts and software function correctly in a controlled environment.


Platforms: Experiments can be tested on a Raspberry Pi 4B (for our Raspberry Pi-based payload) or a dedicated space server testbed. 

Emulation: A Docker-based test environment that mirrors the on-orbit setup is also available for local testing.

Home Directory:  ~ represents /home/u (Raspberry Pi) or /home/user (Space Server). 

### Reconstruction Script Test

In a Docker-based test environment or a physical machine. Place the ground-packaged software (<ID>-<HASH>.pkg) into the ~/udpdatafile directory in the test environment. Manually unwrap the package: tar -C ~/package/ -xvf ${ExperimentID}-${HASH}.pkg. Navigate to the ~/package/ directory. Decompress the core package: tar -zxvf ${ExperimentID}-${HASH}.tgz. Execute the installation script: ./install.sh. Check that the experiment has been correctly installed in the ~/experiment/ and ~/script/ directories.

### Experiment Start-up Script Test
This test verifies that the experiment's start-up script executes correctly.
Prerequisites: The experiment has been successfully installed.
Steps:
Navigate to the experiment's script directory: ~/script/${ExperimentID}
Execute the start-up script (e.g., ./start.sh).
Verify: Check that the experiment has started as expected (e.g., by checking running processes).

### Experiment Stop Script Test
This test verifies that the experiment's stop script functions correctly.
Prerequisites: The experiment is currently running.
Steps:
Navigate to the script directory: ~/script/${ExperimentID}
Execute the stop script (e.g., ./end.sh).
Verify: Check that the experiment has stopped.

### Experiment Runtime Test
This test measures the execution time of the experiment. Navigate to the script directory. Execute the start-up script.

### Experiment Output Test
This test verifies the outputs generated by the experiment. Navigate to the output directory: ~/output/${ExperimentID} Check the output files, recording their contents and sizes. Use the ~/scripts/pack.sh script to package the results and record the final package size.

## Remote Command Test
This phase is critically important, especially for Python-based experiments, as it validates that the scripts can be correctly executed via the on-orbit remote command mechanism, which differs from manual execution.

### Reconstruction Command Test
This test verifies that the software can be correctly reconstructed via a remote command. Place the package in the ~/udpdatafile directory. Start the OBC simulator. From the TUI interface, execute the reconstruction command (e.g., /home/user/scripts/refator-ctl.sh ${ExperimentID}). Check that the experiment is correctly installed in ~/experiment/ and ~/script/.

### Start-up Command Test
This test verifies that the experiment can be started via a remote command. Start the OBC simulator. Execute the start-up command via the TUI (e.g., /home/user/script/${ExperimentID}/${StartupScript}). Check if the experiment has started.

### Stop Command Test
This test verifies that the experiment can be stopped via a remote command. Start the OBC simulator.
Execute the stop command via the TUI (e.g., /home/user/script/${ExperimentID}/${StopScript}). Check if the experiment has stopped.
